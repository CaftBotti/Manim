<!DOCTYPE html>
<h1>Manim Fourier Base</h1>
<p>This base is for users to make Fourier animations quickly. Just import this and write a config, enjoy the beauty of maths!</p>
<p>For more information, See: https://github.com/CaftBotti/Manim/blob/main/ManimFourier</p>
<hr />
<p>#!/usr/bin/env python<br>
# <br>
# MANIM FOURIER BASE<br>
# PUBLIC<br>
# EDITTED BY CAFTBOTTI<br>
# This project is for all users to create Fourier animations quickly. Just import this and write a CONFIG, enjoy the beauty of maths!<br>
#<br>
#<br>
# YOU NEED TO COPY THIS CODE AND IMPORT IT IN YOUR CODE.<br>
# To use, you just need to write a CONFIG: (Ctrl + / to remove comments)<br>
# import manim.fourier.*   # An example of importing, variable file path<br>
# class One(FourierOfPaths):<br>
#     CONFIG = {<br>
#         'n_vectors': 150,<br>
#         'run_time': 100,<br>
#         'slow_factor': 0.2,<br>
#         'tex_class': TextMobject,<br>
#         'tex': '1',<br>
#         'include_zoom_camera': True,<br>
#         'zoom_position': lambda zc: zc.to_corner(DR),<br>
#         'zoom_factor': 0.1,<br>
#         'wait_before_start': 3<br>
#     }<br>
# class Ani25(FourierOfTexSymbol):<br>
#     CONFIG = {<br>
#         'n_vectors': 120,<br>
#         'run_time': 100,<br>
#         'slow_factor': 0.05,<br>
#         'tex_class': TexMobject,<br>
#         'tex': r'\mathrm{Caft~Botti}',<br>
#         'include_zoom_camera': True,<br>
#         'zoom_position': lambda zc: zc.to_corner(DR),<br>
#         'zoom_factor': 0.1,<br>
#         'scale_zoom_camera_to_full_screen': True,<br>
#         'zoom_camera_to_full_screen_config': {<br>
#             'run_time': 12,<br>
#             'func': lambda t: there_and_back_with_pause(t, 1 / 10)<br>
#         },<br>
#         'wait_before_start': 3<br>
#     }<br>
# class Ani22(AbstractFourierOfTexSymbol):<br>
#     CONFIG = {<br>
#         'n_vectors': 120,<br>
#         'run_time': 100,<br>
#         'slow_factor': 0.05,<br>
#         'tex_class': TexMobject,<br>
#         'tex': r'\mathrm{Caft~Botti}',<br>
#         'include_zoom_camera': True,<br>
#         'zoom_position': lambda zc: zc.to_corner(UL),<br>
#         'zoom_factor': 0.1,<br>
#         'scale_zoom_camera_to_full_screen': True,<br>
#         'zoom_camera_to_full_screen_config': {<br>
#             'run_time': 12,<br>
#             'func': lambda t: there_and_back_with_pause(t, 1 / 10)<br>
#         },<br>
#         'wait_before_start': 3<br>
#     }<br>
# class Ani24(FourierFromSVG):<br>
#     CONFIG = {<br>
#         'n_vectors': 120,<br>
#         'run_time': 100,<br>
#         'slow_factor': 0.05,<br>
#         'file_name': 'caftbotti',<br>
#         'zoom_position': lambda zc: zc.to_corner(DR),<br>
#         'zoom_factor': 0.1,<br>
#         'scale_zoom_camera_to_full_screen': True,<br>
#         'zoom_camera_to_full_screen_config': {<br>
#             'run_time': 12,<br>
#             'func': lambda t: there_and_back_with_pause(t, 1 / 10)<br>
#         },<br>
#         'wait_before_start': 3<br>
#     }<br>

<br>
<br>
<br>class FourierCirclesScene(ZoomedScene):<br>
    CONFIG = {<br>
        "n_vectors": 10,<br>
        "big_radius": 2,<br>
        "colors": [<br>
            BLUE_D,<br>
            BLUE_C,<br>
            BLUE_E,<br>
            GREY_BROWN,<br>
        ],<br>
        "vector_config": {<br>
            "buff": 0,<br>
            "max_tip_length_to_length_ratio": 0.25,<br>
            "tip_length": 0.15,<br>
            "max_stroke_width_to_length_ratio": 10,<br>
            "stroke_width": 1.7,<br>
        },<br>
        "circle_config": {<br>
            "stroke_width": 1,<br>
        },<br>
        "base_frequency": 1,<br>
        "slow_factor": 0.5,<br>
        "center_point": ORIGIN,<br>
        "parametric_function_step_size": 0.001,<br>
        "drawn_path_color": YELLOW,<br>
        "drawn_path_stroke_width": 2,<br>
        "interpolate_config": [0, 1],<br>
        # Zoom config<br>
        "include_zoom_camera": False,<br>
        "scale_zoom_camera_to_full_screen": False,<br>
        "scale_zoom_camera_to_full_screen_at": 4,<br>
        "zoom_factor": 0.3,<br>
        "zoomed_display_height": 3,<br>
        "zoomed_display_width": 4,<br>
        "image_frame_stroke_width": 1,<br>
        "zoomed_camera_config": {<br>
            "default_frame_stroke_width": 3,<br>
            "cairo_line_width_multiple": 0.05,<br>
        },<br>
        "zoom_position": lambda mob: mob.move_to(ORIGIN),<br>
        "zoom_camera_to_full_screen_config": {<br>
            "run_time": 3,<br>
            "func": there_and_back_with_pause,<br>
            "velocity_factor": 1<br>
        },<br>
        "wait_before_start": None<br>
    }<br>
 <br>
    def setup(self):<br>
        ZoomedScene.setup(self)<br>
        self.slow_factor_tracker = ValueTracker(<br>
            self.slow_factor<br>
        )<br>
        self.vector_clock = ValueTracker(0)<br>
        self.add(self.vector_clock)<br>
 <br>
    def add_vector_clock(self):<br>
        self.vector_clock.add_updater(<br>
            lambda m, dt: m.increment_value(<br>
                self.get_slow_factor() * dt<br>
            )<br>
        )<br>
 <br>
    def get_slow_factor(self):<br>
        return self.slow_factor_tracker.get_value()<br>
 <br>
    def get_vector_time(self):<br>
        return self.vector_clock.get_value()<br>
 <br>
    def get_freqs(self):<br>
        n = self.n_vectors<br>
        all_freqs = list(range(n // 2, -n // 2, -1))<br>
        all_freqs.sort(key=abs)<br>
        return all_freqs<br>
 <br>
    def get_coefficients(self):<br>
        return [complex(0) for _ in range(self.n_vectors)]<br>
 <br>
    def get_color_iterator(self):<br>
        return it.cycle(self.colors)<br>
 <br>
    def get_rotating_vectors(self, freqs=None, coefficients=None):<br>
        vectors = VGroup()<br>
        self.center_tracker = VectorizedPoint(self.center_point)<br>
 <br>
        if freqs is None:<br>
            freqs = self.get_freqs()<br>
        if coefficients is None:<br>
            coefficients = self.get_coefficients()<br>
 <br>
        last_vector = None<br>
        for freq, coefficient in zip(freqs, coefficients):<br>
            if last_vector:<br>
                center_func = last_vector.get_end<br>
            else:<br>
                center_func = self.center_tracker.get_location<br>
            vector = self.get_rotating_vector(<br>
                coefficient=coefficient,<br>
                freq=freq,<br>
                center_func=center_func,<br>
            )<br>
            vectors.add(vector)<br>
            last_vector = vector<br>
        return vectors<br>
 <br>
    def get_rotating_vector(self, coefficient, freq, center_func):<br>
        vector = Vector(RIGHT, **self.vector_config)<br>
        vector.scale(abs(coefficient))<br>
        if abs(coefficient) == 0:<br>
            phase = 0<br>
        else:<br>
            phase = np.log(coefficient).imag<br>
        vector.rotate(phase, about_point=ORIGIN)<br>
        vector.freq = freq<br>
        vector.coefficient = coefficient<br>
        vector.center_func = center_func<br>
        vector.add_updater(self.update_vector)<br>
        return vector<br>
 <br>
    def update_vector(self, vector, dt):<br>
        time = self.get_vector_time()<br>
        coef = vector.coefficient<br>
        freq = vector.freq<br>
        phase = np.log(coef).imag<br>
 <br>
        vector.set_length(abs(coef))<br>
        vector.set_angle(phase + time * freq * TAU)<br>
        vector.shift(vector.center_func() - vector.get_start())<br>
        return vector<br>
 <br>
    def get_circles(self, vectors):<br>
        return VGroup(*[<br>
            self.get_circle(<br>
                vector,<br>
                color=color<br>
            )<br>
            for vector, color in zip(<br>
                vectors,<br>
                self.get_color_iterator()<br>
            )<br>
        ])<br>
 <br>
    def get_circle(self, vector, color=BLUE):<br>
        circle = Circle(color=color, **self.circle_config)<br>
        circle.center_func = vector.get_start<br>
        circle.radius_func = vector.get_length<br>
        circle.add_updater(self.update_circle)<br>
        return circle<br>
 <br>
    def update_circle(self, circle):<br>
        circle.set_width(2 * circle.radius_func())<br>
        circle.move_to(circle.center_func())<br>
        return circle<br>
 <br>
    def get_vector_sum_path(self, vectors, color=YELLOW):<br>
        coefs = [v.coefficient for v in vectors]<br>
        freqs = [v.freq for v in vectors]<br>
        center = vectors[0].get_start()<br>
 <br>
        path = ParametricFunction(<br>
            lambda t: center + reduce(op.add, [<br>
                complex_to_R3(<br>
                    coef * np.exp(TAU * 1j * freq * t)<br>
                )<br>
                for coef, freq in zip(coefs, freqs)<br>
            ]),<br>
            t_min=0,<br>
            t_max=1,<br>
            color=color,<br>
            step_size=self.parametric_function_step_size,<br>
        )<br>
        return path<br>
 <br>
    def get_drawn_path_alpha(self):<br>
        return self.get_vector_time()<br>
 <br>
    def get_drawn_path(self, vectors, stroke_width=None, **kwargs):<br>
        if stroke_width is None:<br>
            stroke_width = self.drawn_path_stroke_width<br>
        path = self.get_vector_sum_path(vectors, **kwargs)<br>
        broken_path = CurvesAsSubmobjects(path)<br>
        broken_path.curr_time = 0<br>
        start, end = self.interpolate_config<br>
 <br>
        def update_path(path, dt):<br>
            alpha = self.get_drawn_path_alpha()<br>
            n_curves = len(path)<br>
            for a, sp in zip(np.linspace(0, 1, n_curves), path):<br>
                b = (alpha - a)<br>
                if b < 0:<br>
                    width = 0<br>
                else:<br>
                    width = stroke_width * interpolate(start, end, (1 - (b % 1)))<br>
                sp.set_stroke(width=width)<br>
            path.curr_time += dt<br>
            return path<br>
 <br>
        broken_path.set_color(self.drawn_path_color)<br>
        broken_path.add_updater(update_path)<br>
        return broken_path<br>
 <br>
    def get_y_component_wave(self,<br>
                             vectors,<br>
                             left_x=1,<br>
                             color=PINK,<br>
                             n_copies=2,<br>
                             right_shift_rate=5):<br>
        path = self.get_vector_sum_path(vectors)<br>
        wave = ParametricFunction(<br>
            lambda t: op.add(<br>
                right_shift_rate * t * LEFT,<br>
                path.function(t)[1] * UP<br>
            ),<br>
            t_min=path.t_min,<br>
            t_max=path.t_max,<br>
            color=color,<br>
        )<br>
        wave_copies = VGroup(*[<br>
            wave.copy()<br>
            for x in range(n_copies)<br>
        ])<br>
        wave_copies.arrange(RIGHT, buff=0)<br>
        top_point = wave_copies.get_top()<br>
        wave.creation = ShowCreation(<br>
            wave,<br>
            run_time=(1 / self.get_slow_factor()),<br>
            rate_func=linear,<br>
        )<br>
        cycle_animation(wave.creation)<br>
        wave.add_updater(lambda m: m.shift(<br>
            (m.get_left()[0] - left_x) * LEFT<br>
        ))<br>
 <br>
        def update_wave_copies(wcs):<br>
            index = int(<br>
                wave.creation.total_time * self.get_slow_factor()<br>
            )<br>
            wcs[:index].match_style(wave)<br>
            wcs[index:].set_stroke(width=0)<br>
            wcs.next_to(wave, RIGHT, buff=0)<br>
            wcs.align_to(top_point, UP)<br>
        wave_copies.add_updater(update_wave_copies)<br>
 <br>
        return VGroup(wave, wave_copies)<br>
 <br>
    def get_wave_y_line(self, vectors, wave):<br>
        return DashedLine(<br>
            vectors[-1].get_end(),<br>
            wave[0].get_end(),<br>
            stroke_width=1,<br>
            dash_length=DEFAULT_DASH_LENGTH * 0.5,<br>
        )<br>
 <br>
    def get_coefficients_of_path(self, path, n_samples=10000, freqs=None):<br>
        if freqs is None:<br>
            freqs = self.get_freqs()<br>
        dt = 1 / n_samples<br>
        ts = np.arange(0, 1, dt)<br>
        samples = np.array([<br>
            path.point_from_proportion(t)<br>
            for t in ts<br>
        ])<br>
        samples -= self.center_point<br>
        complex_samples = samples[:, 0] + 1j * samples[:, 1]<br>
 <br>
        return [<br>
            np.array([<br>
                np.exp(-TAU * 1j * freq * t) * cs<br>
                for t, cs in zip(ts, complex_samples)<br>
            ]).sum() * dt for freq in freqs<br>
        ]<br>
 <br>
    def zoom_config(self):<br>
        # This is not in the original version of the code.<br>
        self.activate_zooming(animate=False)<br>
        self.zoom_position(self.zoomed_display)<br>
        self.zoomed_camera.frame.add_updater(lambda mob: mob.move_to(self.vectors[-1].get_end()))<br>
 <br>
    def scale_zoom_camera_to_full_screen_config(self):<br>
        # This is not in the original version of the code.<br>
        def fix_update(mob, dt, velocity_factor, dt_calculate):<br>
            if dt == 0 and mob.counter == 0:<br>
                rate = velocity_factor * dt_calculate<br>
                mob.counter += 1<br>
            else:<br>
                rate = dt * velocity_factor<br>
            if dt > 0:<br>
                mob.counter = 0<br>
            return rate<br>
 <br>
        fps = 1 / self.camera.frame_rate<br>
        mob = self.zoomed_display<br>
        mob.counter = 0<br>
        velocity_factor = self.zoom_camera_to_full_screen_config["velocity_factor"]<br>
        mob.start_time = 0<br>
        run_time = self.zoom_camera_to_full_screen_config["run_time"]<br>
        run_time *= 2<br>
        mob_height = mob.get_height()<br>
        mob_width = mob.get_width()<br>
        mob_center = mob.get_center()<br>
        ctx = self.zoomed_camera.cairo_line_width_multiple<br>
 <br>
        def update_camera(mob, dt):<br>
            line = Line(<br>
                mob_center,<br>
                self.camera_frame.get_center()<br>
            )<br>
            mob.start_time += fix_update(mob, dt, velocity_factor, fps)<br>
            if mob.start_time <= run_time:<br>
                alpha = mob.start_time / run_time<br>
                alpha_func = self.zoom_camera_to_full_screen_config["func"](alpha)<br>
                coord = line.point_from_proportion(alpha_func)<br>
                mob.set_height(<br>
                    interpolate(<br>
                        mob_height,<br>
                        self.camera_frame.get_height(),<br>
                        alpha_func<br>
                    ),<br>
                    stretch=True<br>
                )<br>
                mob.set_width(<br>
                    interpolate(<br>
                        mob_width,<br>
                        self.camera_frame.get_width(),<br>
                        alpha_func<br>
                    ),<br>
                    stretch=True<br>
                )<br>
                self.zoomed_camera.cairo_line_width_multiple = interpolate(<br>
                    ctx,<br>
                    self.camera.cairo_line_width_multiple,<br>
                    alpha_func<br>
                )<br>
                mob.move_to(coord)<br>
            return mob<br>
 <br>
        self.zoomed_display.add_updater(update_camera)<br>
 <br>
 <br>
class AbstractFourierOfTexSymbol(FourierCirclesScene):<br>
    CONFIG = {<br>
        "n_vectors": 50,<br>
        "center_point": ORIGIN,<br>
        "slow_factor": 0.05,<br>
        "n_cycles": None,<br>
        "run_time": 10,<br>
        "tex": r"\rm M",<br>
        "start_drawn": True,<br>
        "path_custom_position": lambda mob: mob,<br>
        "max_circle_stroke_width": 1,<br>
        "tex_class": TexMobject,<br>
        "tex_config": {<br>
            "fill_opacity": 0,<br>
            "stroke_width": 1,<br>
            "stroke_color": WHITE<br>
        },<br>
        "include_zoom_camera": False,<br>
        "scale_zoom_camera_to_full_screen": False,<br>
        "scale_zoom_camera_to_full_screen_at": 1,<br>
        "zoom_position": lambda mob: mob.scale(0.8).move_to(ORIGIN).to_edge(RIGHT)<br>
    }<br>
 <br>
    def construct(self):<br>
        # This is not in the original version of the code.<br>
        self.add_vectors_circles_path()<br>
        if self.wait_before_start != None:<br>
            self.wait(self.wait_before_start)<br>
        self.add_vector_clock()<br>
        self.add(self.vector_clock)<br>
        if self.include_zoom_camera:<br>
            self.zoom_config()<br>
        if self.scale_zoom_camera_to_full_screen:<br>
            self.run_time -= self.scale_zoom_camera_to_full_screen_at<br>
            self.wait(self.scale_zoom_camera_to_full_screen_at)<br>
            self.scale_zoom_camera_to_full_screen_config()<br>
        if self.n_cycles != None:<br>
            if not self.scale_zoom_camera_to_full_screen:<br>
                for n in range(self.n_cycles):<br>
                   self.run_one_cycle()<br>
            else:<br>
                cycle = 1 / self.slow_factor<br>
                total_time = cycle * self.n_cycles<br>
                total_time -= self.scale_zoom_camera_to_full_screen_at<br>
                self.wait(total_time)<br>
        elif self.run_time != None:<br>
            self.wait(self.run_time)<br>
 <br>
    def add_vectors_circles_path(self):<br>
        path = self.get_path()<br>
        self.path_custom_position(path)<br>
        coefs = self.get_coefficients_of_path(path)<br>
        vectors = self.get_rotating_vectors(coefficients=coefs)<br>
        circles = self.get_circles(vectors)<br>
        self.set_decreasing_stroke_widths(circles)<br>
        drawn_path = self.get_drawn_path(vectors)<br>
        if self.start_drawn:<br>
            self.vector_clock.increment_value(1)<br>
        self.add(path)<br>
        self.add(vectors)<br>
        self.add(circles)<br>
        self.add(drawn_path)<br>
 <br>
        self.vectors = vectors<br>
        self.circles = circles<br>
        self.path = path<br>
        self.drawn_path = drawn_path<br>
 <br>
    def run_one_cycle(self):<br>
        time = 1 / self.slow_factor<br>
        self.wait(time)<br>
 <br>
    def set_decreasing_stroke_widths(self, circles):<br>
        mcsw = self.max_circle_stroke_width<br>
        for k, circle in zip(it.count(1), circles):<br>
            circle.set_stroke(width=max(<br>
                mcsw / k,<br>
                mcsw,<br>
            ))<br>
        return circles<br>
 <br>
    def get_path(self):<br>
        tex_mob = self.tex_class(self.tex, **self.tex_config)<br>
        tex_mob.set_height(6)<br>
        path = tex_mob.family_members_with_points()[0]<br>
        return path<br>
 <br>
 <br>
class AbstractFourierFromSVG(AbstractFourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 101,<br>
        "run_time": 10,<br>
        "start_drawn": True,<br>
        "file_name": None,<br>
        "svg_config": {<br>
            "fill_opacity": 0,<br>
            "stroke_color": WHITE,<br>
            "stroke_width": 1,<br>
            "height": 7<br>
        }<br>
    }<br>
 <br>
    def get_shape(self):<br>
        shape = SVGMobject(self.file_name, **self.svg_config)<br>
        return shape<br>
 <br>
    def get_path(self):<br>
        shape = self.get_shape()<br>
        path = shape.family_members_with_points()[0]<br>
        return path<br>
 <br>
 <br>
 <br>
class FourierOfPaths(AbstractFourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 100,<br>
        "name_color": WHITE,<br>
        "tex_class": TexMobject,<br>
        "tex": None,<br>
        "file_name": None,<br>
        "tex_config": {<br>
            "stroke_color": WHITE,<br>
            "fill_opacity": 0,<br>
            "stroke_width": 3,<br>
        },<br>
        "svg_config": {},<br>
        "time_per_symbol": 5,<br>
        "slow_factor": 1 / 5,<br>
        "parametric_function_step_size": 0.01,<br>
        "include_zoom_camera": False,<br>
        "scale_zoom_camera_to_full_screen": False,<br>
    }<br>
 <br>
    def construct(self):<br>
        self.add_vector_clock()<br>
        if self.tex != None:<br>
            name = self.tex_class(self.tex, **self.tex_config)<br>
        elif self.file_name != None and self.tex == None:<br>
            name = SVGMobject(self.file_name, **self.svg_config)<br>
        max_width = FRAME_WIDTH - 2<br>
        max_height = FRAME_HEIGHT - 2<br>
        name.set_width(max_width)<br>
        if name.get_height() > max_height:<br>
            name.set_height(max_height)<br>
 <br>
        frame = self.camera.frame<br>
        frame.save_state()<br>
 <br>
        vectors = VGroup(VectorizedPoint())<br>
        circles = VGroup(VectorizedPoint())<br>
        for path in name.family_members_with_points():<br>
            for subpath in path.get_subpaths():<br>
                sp_mob = VMobject()<br>
                sp_mob.set_points(subpath)<br>
                coefs = self.get_coefficients_of_path(sp_mob)<br>
                new_vectors = self.get_rotating_vectors(<br>
                    coefficients=coefs<br>
                )<br>
                new_circles = self.get_circles(new_vectors)<br>
                self.set_decreasing_stroke_widths(new_circles)<br>
 <br>
                drawn_path = self.get_drawn_path(new_vectors)<br>
                drawn_path.clear_updaters()<br>
                drawn_path.set_style(**self.tex_config)<br>
                drawn_path.set_style(**self.svg_config)<br>
 <br>
                static_vectors = VMobject().become(new_vectors)<br>
                static_circles = VMobject().become(new_circles)<br>
 <br>
                self.play(<br>
                    Transform(vectors, static_vectors, remover=True),<br>
                    Transform(circles, static_circles, remover=True),<br>
                    frame.set_height, 1.5 * name.get_height(),<br>
                    frame.move_to, path,<br>
                )<br>
 <br>
                self.add(new_vectors, new_circles)<br>
                self.vector_clock.set_value(0)<br>
                self.play(<br>
                    ShowCreation(drawn_path),<br>
                    rate_func=linear,<br>
                    run_time=self.time_per_symbol<br>
                )<br>
                self.remove(new_vectors, new_circles)<br>
                self.add(static_vectors, static_circles)<br>
 <br>
                vectors = static_vectors<br>
                circles = static_circles<br>
        self.play(<br>
            FadeOut(vectors),<br>
            FadeOut(circles),<br>
            Restore(frame),<br>
            run_time=2<br>
        )<br>
        self.wait(3)<br>
        <br>
    <br>
# Using TexMobject or TextMobject<br>
class FourierOfTexSymbol(AbstractFourierOfTexSymbol):<br>
    CONFIG = {<br>
        # if start_draw = True the path start to draw<br>
        "start_drawn": True,<br>
        # Tex config<br>
        "tex_class": TexMobject,<br>
        "tex": r"\Sigma",<br>
        "tex_config": {<br>
            "fill_opacity": 0,<br>
            "stroke_width": 1,<br>
            "stroke_color": WHITE<br>
        },<br>
        # Draw config<br>
        "drawn_path_color": YELLOW,<br>
        "interpolate_config": [0, 1],<br>
        "n_vectors": 50,<br>
        "big_radius": 2,<br>
        "drawn_path_stroke_width": 2,<br>
        "center_point": ORIGIN,<br>
        # Duration config<br>
        "slow_factor": 0.1,<br>
        "n_cycles": None,<br>
        "run_time": 10,<br>
        # colors of circles<br>
        "colors": [<br>
            BLUE_D,<br>
            BLUE_C,<br>
            BLUE_E,<br>
            GREY_BROWN,<br>
        ],<br>
        # circles config<br>
        "circle_config": {<br>
            "stroke_width": 1,<br>
        },<br>
        # vector config<br>
        "vector_config": {<br>
            "buff": 0,<br>
            "max_tip_length_to_length_ratio": 0.25,<br>
            "tip_length": 0.15,<br>
            "max_stroke_width_to_length_ratio": 10,<br>
            "stroke_width": 1.7,<br>
        },<br>
        "base_frequency": 1,<br>
        # definition of subpaths<br>
        "parametric_function_step_size": 0.001,<br>
    }<br>
 <br>
# Tex examples -------------------------------------------<br>
# n_vectors<br>
class Tsymbol20vectors(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 20,<br>
        "run_time": 10, # 10 seconds<br>
        "tex_class": TextMobject,<br>
        "tex": "T"<br>
    }<br>
 <br>
class Tsymbol50vectors(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 50,<br>
        "run_time": 10, # 10 seconds<br>
        "tex_class": TextMobject,<br>
        "tex": "T"<br>
    }<br>
 <br>
class Tsymbol150vectors(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 150,<br>
        "run_time": 10, # 10 seconds<br>
        "tex_class": TextMobject,<br>
        "tex": "T"<br>
    }<br>
 <br>
class SigmaSymbol150vectors(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 150,<br>
        "run_time": 10, # 10 seconds<br>
        "tex_class": TexMobject, # <-------- Default<br>
        "tex": "\\Sigma"<br>
    }<br>
 <br>
# slow_factor<br>
class SlowFactor0_1(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 30,<br>
        "run_time": 7,<br>
        "tex_class": TexMobject,<br>
        "tex": "\\Sigma",<br>
        "slow_factor": 0.1, # <------------------ Default<br>
    }<br>
 <br>
class SlowFactor0_3(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 30,<br>
        "run_time": 7,<br>
        "tex_class": TexMobject,<br>
        "tex": "\\Sigma",<br>
        "slow_factor": 0.3, # <------------------<br>
    }<br>
 <br>
class SlowFactor0_5(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 30,<br>
        "run_time": 7,<br>
        "tex_class": TexMobject,<br>
        "tex": "\\Sigma",<br>
        "slow_factor": 0.5, # <------------------<br>
    }<br>
 <br>
# start_drawn<br>
class StartDrawTrue(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "slow_factor": 0.05,<br>
        "n_vectors": 30,<br>
        "run_time": 15,<br>
        "tex": "\\tau",<br>
        "start_drawn": True # <------------------ Default<br>
    }<br>
 <br>
class StartDrawFalse(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "slow_factor": 0.05,<br>
        "n_vectors": 30,<br>
        "run_time": 15,<br>
        "tex": "\\tau",<br>
        "start_drawn": False # <------------------<br>
    }<br>
 <br>
# interpolate_config<br>
class InterpolateConfig0to1(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "slow_factor": 0.05,<br>
        "n_vectors": 30,<br>
        "run_time": 15,<br>
        "tex": "\\tau",<br>
        "interpolate_config": [0, 1] # <---------- Default<br>
    }<br>
 <br>
class InterpolateConfig0_3to_1(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "slow_factor": 0.05,<br>
        "n_vectors": 30,<br>
        "run_time": 15,<br>
        "tex": "\\tau",<br>
        "interpolate_config": [0.3, 1] # <---------- <br>
    }<br>
 <br>
class InterpolateConfig1_to_1(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "slow_factor": 0.05,<br>
        "n_vectors": 30,<br>
        "run_time": 15,<br>
        "tex": "\\tau",<br>
        "interpolate_config": [1, 1] # <---------- # always write<br>
    }<br>
 <br>
# n_cycles vs run_time<br>
class NCyclesVsRunTime(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 30,<br>
        "n_cycles": 3,<br>
        "tex": "\\tau",<br>
    }<br>
 <br>
# wait_before_start<br>
class WaitBeforeStart(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 30,<br>
        "n_cycles": 1,<br>
        "tex": "\\tau",<br>
        "wait_before_start": 2<br>
    }<br>
 <br>
# center_point<br>
class CenterPoint(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 30,<br>
        "n_cycles": 1,<br>
        "tex": "\\tau",<br>
        "center_point": RIGHT*3<br>
    }<br>
 <br>
# path_custom_position<br>
class CustomPosition(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "n_vectors": 30,<br>
        "n_cycles": 1,<br>
        "tex": "\\tau",<br>
        "center_point": RIGHT*3,<br>
        "path_custom_position": lambda mob: mob.to_edge(LEFT),<br>
        "circle_config": {<br>
            "stroke_opacity": 0,<br>
        },<br>
    }<br>
 <br>
# SVG<br>
class FourierFromSVG(AbstractFourierFromSVG):<br>
    CONFIG = {<br>
        # if start_draw = True the path start to draw<br>
        "start_drawn": True,<br>
        # SVG file name<br>
        "file_name": None,<br>
        "svg_config": {<br>
            "fill_opacity": 0,<br>
            "stroke_color": WHITE,<br>
            "stroke_width": 1,<br>
            "height": 7<br>
        },<br>
        # Draw config<br>
        "drawn_path_color": YELLOW,<br>
        "interpolate_config": [0, 1],<br>
        "n_vectors": 50,<br>
        "big_radius": 2,<br>
        "drawn_path_stroke_width": 2,<br>
        "center_point": ORIGIN,<br>
        # Duration config<br>
        "slow_factor": 0.1,<br>
        "n_cycles": None,<br>
        "run_time": 10,<br>
        # colors of circles<br>
        "colors": [<br>
            BLUE_D,<br>
            BLUE_C,<br>
            BLUE_E,<br>
            GREY_BROWN,<br>
        ],<br>
        # circles config<br>
        "circle_config": {<br>
            "stroke_width": 1,<br>
        },<br>
        # vector config<br>
        "vector_config": {<br>
            "buff": 0,<br>
            "max_tip_length_to_length_ratio": 0.25,<br>
            "tip_length": 0.15,<br>
            "max_stroke_width_to_length_ratio": 10,<br>
            "stroke_width": 1.7,<br>
        },<br>
        "base_frequency": 1,<br>
        # definition of subpaths<br>
        "parametric_function_step_size": 0.001,<br>
    }<br>
 <br>
# file_name<br>
class SVGDefault(FourierFromSVG):<br>
    CONFIG = {<br>
        "n_vectors": 100,<br>
        "n_cycles": 1,<br>
        "file_name": "c_clef", # in assets/svg_images/c_clef.svg<br>
    }<br>
    <br>
    <br>
    <br>
    <br>
class ZoomedActivate(FourierFromSVG):<br>
    CONFIG = {<br>
        "slow_factor": 0.05,<br>
        "n_vectors": 50,<br>
        "n_cycles": 1,<br>
        "file_name": "c_clef",<br>
        "include_zoom_camera": True,<br>
        "zoom_position": lambda zc: zc.to_corner(DR)<br>
    }<br>
 <br>
# Zoomed camera: Moving camera<br>
# Zoomed display: Static camera<br>
# More info: https://github.com/Elteoremadebeethoven/AnimationsWithManim/blob/master/English/extra/faqs/faqs.md#zoomed-scene-example<br>
class ZoomedConfig(FourierFromSVG):<br>
    CONFIG = {<br>
        "slow_factor": 0.05,<br>
        "n_vectors": 150,<br>
        "n_cycles": 1,<br>
        "file_name": "c_clef",<br>
        "path_custom_position": lambda path: path.shift(LEFT*2),<br>
        "center_point": LEFT*2,<br>
        "circle_config": {<br>
            "stroke_width": 0.5,<br>
            "stroke_opacity": 0.2,<br>
        },<br>
        # Zoom config<br>
        "include_zoom_camera": True,<br>
        "zoom_position": lambda zc: zc.to_edge(RIGHT).set_y(0),<br>
        "zoom_factor": 0.5,<br>
        "zoomed_display_height": 5,<br>
        "zoomed_display_width": 5,<br>
        "zoomed_camera_config": {<br>
            "default_frame_stroke_width": 3,<br>
            "cairo_line_width_multiple": 0.05,<br>
            # What is cairo_line_width_multiple?<br>
            # See here: https://stackoverflow.com/questions/60765530/manim-zoom-not-preserving-line-thickness<br>
        },<br>
    }<br>
 <br>
# Move Zoomed display to full screen<br>
class ZoomedDisplayToFullScreen(FourierOfTexSymbol):<br>
    CONFIG = {<br>
        "slow_factor": 0.05,<br>
        "n_vectors": 30,<br>
        "run_time": 16,<br>
        "tex": "\\tau",<br>
        # Zoom config<br>
        "include_zoom_camera": True,<br>
        "zoom_position": lambda zc: zc.to_corner(DR),<br>
        # Zoomed display to Full screen config<br>
        "scale_zoom_camera_to_full_screen": True,<br>
        "scale_zoom_camera_to_full_screen_at": 4, # Move the camera at 4 seconds<br>
        "zoom_camera_to_full_screen_config": {<br>
            "run_time": 3,<br>
            "func": smooth,<br>
            "velocity_factor": 1<br>
        },<br>
    }<br>
 <br>
class ZoomedDisplayToFullScreenWithRestore(ZoomedDisplayToFullScreen):<br>
    CONFIG = {<br>
        "run_time": 20,<br>
        "zoom_camera_to_full_screen_config": {<br>
            "run_time": 12,<br>
            "func": lambda t: there_and_back_with_pause(t, 1/10),<br>
            # learn more: manimlib/utils/rate_functions.py<br>
        },<br>
    }<br>
    <br>
    <br>
class FourierOfPathsTB(FourierOfPaths):<br>
    CONFIG = {<br>
        "n_vectors": 100,<br>
        "tex_class": TextMobject,<br>
        "tex": "TB",<br>
        "tex_config": {<br>
            "stroke_color": RED,<br>
        },<br>
        "time_per_symbol": 5,<br>
        "slow_factor": 1 / 5,<br>
    }<br>
 <br>
 <br>
# Convert objects to paths<br>
# Inkscape example: [ToolBar] Path > Object to path<br>
class FourierOfPathsSVG(FourierOfPaths):<br>
    CONFIG = {<br>
        "n_vectors": 100,<br>
        "file_name": "music_symbols",<br>
        "svg_config": {<br>
            "stroke_color": RED,<br>
        },<br>
        "time_per_symbol": 5,<br>
        "slow_factor": 1 / 5,<br>
    }<br>
    <br>
    <br>
class CustomAnimationExample(FourierCirclesScene):<br>
    CONFIG = {<br>
        "n_vectors": 200,<br>
        "slow_factor": 0.2,<br>
        "fourier_symbol_config": {<br>
            "stroke_width": 0,<br>
            "fill_opacity": 0,<br>
            "height": 4,<br>
            "fill_color": WHITE<br>
        },<br>
        "circle_config": {<br>
            "stroke_width": 1,<br>
            "stroke_opacity": 0.3,<br>
        },<br>
    }<br>
    def construct(self):<br>
        t_symbol = TextMobject("T", **self.fourier_symbol_config)<br>
        c_clef_symbol = SVGMobject("c_clef", **self.fourier_symbol_config)<br>
        c_clef_symbol.match_height(t_symbol)<br>
        # set gradient<br>
        for mob in [t_symbol,c_clef_symbol]:<br>
            mob.set_sheen(0,UP)<br>
            mob.set_color(color=[BLACK,GRAY,WHITE])<br>
        group = VGroup(t_symbol,c_clef_symbol).arrange(RIGHT,buff=0.1)<br>
        # set paths<br>
        path1 = t_symbol.family_members_with_points()[0]<br>
        path2 = c_clef_symbol.family_members_with_points()[0]<br>
        # path 1 config<br>
        coefs1 = self.get_coefficients_of_path(path1)<br>
        vectors1 = self.get_rotating_vectors(coefficients=coefs1)<br>
        circles1 = self.get_circles(vectors1)<br>
        drawn_path1 = self.get_drawn_path(vectors1)<br>
        # path 2 config<br>
        coefs2 = self.get_coefficients_of_path(path2)<br>
        vectors2 = self.get_rotating_vectors(coefficients=coefs2)<br>
        circles2 = self.get_circles(vectors2)<br>
        drawn_path2= self.get_drawn_path(vectors2)<br>
        # text definition<br>
        text = TextMobject("Thanks for watch!")<br>
        text.scale(1.5)<br>
        text.next_to(group,DOWN)<br>
        # all elements toget<br>
        all_mobs = VGroup(group,text)<br>
        # set mobs to remove<br>
        vectors1_to_fade = vectors1.copy()<br>
        circles1_to_fade = circles1.copy()<br>
        vectors1_to_fade.clear_updaters()<br>
        circles1_to_fade.clear_updaters()<br>
        vectors2_to_fade = vectors2.copy()<br>
        circles2_to_fade = circles2.copy()<br>
        vectors2_to_fade.clear_updaters()<br>
        circles2_to_fade.clear_updaters()<br>
 <br>
        self.play(<br>
            *[<br>
                GrowArrow(arrow)<br>
                for vg in [vectors1_to_fade, vectors2_to_fade]<br>
                for arrow in vg<br>
            ],<br>
            *[<br>
                ShowCreation(circle)<br>
                for cg in [circles1_to_fade, circles2_to_fade]<br>
                for circle in cg<br>
            ],<br>
            run_time=2.5,<br>
        )<br>
        self.remove(<br>
            *vectors1_to_fade,<br>
            *circles1_to_fade,<br>
            *vectors2_to_fade,<br>
            *circles2_to_fade,<br>
        )<br>
        self.add(<br>
            vectors1,<br>
            circles1,<br>
            drawn_path1.set_color(RED),<br>
            vectors2,<br>
            circles2,<br>
            drawn_path2.set_color(BLUE),<br>
        )<br>
        self.add_vector_clock()<br>
 <br>
        # wait one cycle<br>
        self.wait( 1 / self.slow_factor)<br>
        self.bring_to_back(t_symbol,c_clef_symbol)<br>
        self.play(<br>
            t_symbol.set_fill,None,1,<br>
            c_clef_symbol.set_fill,None,1,<br>
            run_time=3<br>
        )<br>
        self.wait()<br>
        # move camera<br>
        self.play(<br>
            self.camera_frame.set_height, all_mobs.get_height()*1.2,<br>
            self.camera_frame.move_to, all_mobs.get_center()<br>
        )<br>
        self.wait(0.5)<br>
        self.play(<br>
            Write(text)<br>
        )<br>
        self.wait(10)<br>
  </p>
